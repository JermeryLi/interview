volatile是什么？谈谈对它的理解。

atomic 原子
	atomicIntegter
	Lock synchronized
auto 自动

volatile是Java虚拟机提供的轻量级的同步机制。
三大特性： 保证可见性、不保证原子性、禁止指令重排序

1、保证可见性	
	某个线程修改了主内存的值后，其他的线程会获得通知。
	一个线程修改了共享变量的值还未写会主内存是，如果另一个线程又对主内存中的同一个共享变量
	进行操作。工作内存与主内存延迟同步的现象会造成可见性问题。
2、不保证原子性
	原子行：不可分割、完整性、某个线程在做某个具体业务时，中间不可以被加塞或者分割。
	需要整体完整，要么同时成功，要么同时失败。
	解决volatile非原子性的办法：
		1、synchronized
		2、 atomicIntegter
3、禁止指令重排序
	计算机在执行程序时，为了提高性能，编辑器和处理器常常会对指令做重排：
		源代码-> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行的指令
	单线程环境里确保程序最终执行结果的代码顺序执行的结果一致。
	处理器在进行重排序时必须要考虑指令之间的数据依赖性。
	多线程环境中线程交替执行，由于编辑器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。
	

JVM：Java虚拟机
JMM: Java内存模型，是一种抽象概念，并不是真实存在。
	 它描述的是一种规则或者规范。
	 通过这组规范定义了程序中各个变量（实例字段、静态字段和构数组对象的元素）的访问方式。
	 关于同步的规定:
		1、线程解锁前，必须把共享变量的值刷新回主内存；
		2、线程加锁前，必须把主内存的最新值读取到自己的工作内存；
		3、加锁解锁是同一把锁。
	
	由于JVM运行的程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（或称之为栈空间），
	工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存。
	主内存是共享内存区域，所有线程都可以访问。
	但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存中，
	然后对变量进行操作。操作完成后将变量写会主内存。
	不能直接操作主内存中的变量，各个线程中工作内存中存储这个主内存中的变量副本拷贝。
	因此不同线程间无法访问对方的工作内存，线程间的通信必须通过主内存来完成。
	


	
